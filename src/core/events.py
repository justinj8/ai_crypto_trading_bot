"""
Event System for Event-Driven Architecture
Supports market data events, signal events, order events, and fill events
"""
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional
from queue import Queue, Empty


class EventType(Enum):
    """Types of events in the trading system"""
    MARKET = "MARKET"
    SIGNAL = "SIGNAL"
    ORDER = "ORDER"
    FILL = "FILL"
    POSITION = "POSITION"
    RISK = "RISK"
    PERFORMANCE = "PERFORMANCE"
    SYSTEM = "SYSTEM"


class OrderType(Enum):
    """Order types"""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"


class OrderSide(Enum):
    """Order side"""
    BUY = "BUY"
    SELL = "SELL"


class SignalType(Enum):
    """Trading signal types"""
    LONG = "LONG"
    SHORT = "SHORT"
    EXIT = "EXIT"
    CLOSE = "CLOSE"


@dataclass
class Event:
    """Base event class"""
    event_type: EventType
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class MarketEvent(Event):
    """
    Market data event
    Triggered when new market data is received
    """
    symbol: str
    timeframe: str
    open: float
    high: float
    low: float
    close: float
    volume: float
    data: Dict[str, Any] = field(default_factory=dict)  # Additional data (indicators, etc.)

    def __post_init__(self):
        self.event_type = EventType.MARKET


@dataclass
class SignalEvent(Event):
    """
    Trading signal event
    Generated by strategies to indicate trading opportunities
    """
    strategy_name: str
    symbol: str
    signal_type: SignalType
    strength: float  # Signal strength 0-1
    target_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: float = 0.0  # Model confidence 0-1
    reasoning: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        self.event_type = EventType.SIGNAL


@dataclass
class OrderEvent(Event):
    """
    Order event
    Generated by portfolio/risk management to place orders
    """
    symbol: str
    order_type: OrderType
    side: OrderSide
    quantity: float
    price: Optional[float] = None  # For limit orders
    stop_price: Optional[float] = None  # For stop orders
    time_in_force: str = "GTC"  # GTC, IOC, FOK
    strategy_name: str = ""
    signal_id: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        self.event_type = EventType.ORDER


@dataclass
class FillEvent(Event):
    """
    Fill event
    Generated when an order is executed
    """
    order_id: str
    symbol: str
    side: OrderSide
    quantity: float
    fill_price: float
    commission: float
    exchange: str
    timestamp: datetime = field(default_factory=datetime.utcnow)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        self.event_type = EventType.FILL

    @property
    def fill_cost(self) -> float:
        """Total cost including commission"""
        return (self.quantity * self.fill_price) + self.commission


@dataclass
class PositionEvent(Event):
    """
    Position update event
    Generated when positions are opened, closed, or modified
    """
    symbol: str
    action: str  # OPENED, CLOSED, MODIFIED
    quantity: float
    avg_price: float
    current_price: float
    unrealized_pnl: float
    realized_pnl: float = 0.0
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        self.event_type = EventType.POSITION


@dataclass
class RiskEvent(Event):
    """
    Risk event
    Generated when risk limits are breached or warnings occur
    """
    risk_type: str  # LIMIT_BREACH, WARNING, CIRCUIT_BREAKER
    severity: str  # INFO, WARNING, CRITICAL
    message: str
    metric: str  # What metric triggered the event
    current_value: float
    limit_value: float
    action_taken: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        self.event_type = EventType.RISK


@dataclass
class PerformanceEvent(Event):
    """
    Performance metrics event
    Generated periodically to report performance
    """
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    total_trades: int
    profitable_trades: int
    current_capital: float
    metrics: Dict[str, float] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        self.event_type = EventType.PERFORMANCE


class EventQueue:
    """
    Thread-safe event queue for the trading system
    """

    def __init__(self, maxsize: int = 0):
        """
        Initialize event queue

        Args:
            maxsize: Maximum queue size (0 = unlimited)
        """
        self._queue = Queue(maxsize=maxsize)
        self._event_counts = {event_type: 0 for event_type in EventType}

    def put(self, event: Event, block: bool = True, timeout: Optional[float] = None):
        """
        Add event to queue

        Args:
            event: Event to add
            block: Block if queue is full
            timeout: Timeout for blocking
        """
        self._queue.put(event, block=block, timeout=timeout)
        self._event_counts[event.event_type] += 1

    def get(self, block: bool = True, timeout: Optional[float] = None) -> Optional[Event]:
        """
        Get event from queue

        Args:
            block: Block if queue is empty
            timeout: Timeout for blocking

        Returns:
            Event or None if queue is empty
        """
        try:
            return self._queue.get(block=block, timeout=timeout)
        except Empty:
            return None

    def empty(self) -> bool:
        """Check if queue is empty"""
        return self._queue.empty()

    def size(self) -> int:
        """Get current queue size"""
        return self._queue.qsize()

    def get_event_counts(self) -> Dict[EventType, int]:
        """Get counts of events by type"""
        return self._event_counts.copy()

    def clear(self):
        """Clear all events from queue"""
        while not self.empty():
            try:
                self._queue.get_nowait()
            except Empty:
                break
        self._event_counts = {event_type: 0 for event_type in EventType}


class EventBus:
    """
    Event bus for publishing and subscribing to events
    Supports multiple subscribers per event type
    """

    def __init__(self):
        """Initialize event bus"""
        self._subscribers = {event_type: [] for event_type in EventType}

    def subscribe(self, event_type: EventType, callback):
        """
        Subscribe to event type

        Args:
            event_type: Type of event to subscribe to
            callback: Function to call when event is published
        """
        if callback not in self._subscribers[event_type]:
            self._subscribers[event_type].append(callback)

    def unsubscribe(self, event_type: EventType, callback):
        """
        Unsubscribe from event type

        Args:
            event_type: Type of event to unsubscribe from
            callback: Callback function to remove
        """
        if callback in self._subscribers[event_type]:
            self._subscribers[event_type].remove(callback)

    def publish(self, event: Event):
        """
        Publish event to all subscribers

        Args:
            event: Event to publish
        """
        for callback in self._subscribers[event.event_type]:
            try:
                callback(event)
            except Exception as e:
                print(f"Error in event subscriber: {e}")

    def clear_subscribers(self, event_type: Optional[EventType] = None):
        """
        Clear subscribers

        Args:
            event_type: Event type to clear, or None to clear all
        """
        if event_type:
            self._subscribers[event_type] = []
        else:
            self._subscribers = {event_type: [] for event_type in EventType}
